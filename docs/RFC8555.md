RFC8555.md

# Overview
   o  The operator's ACME client prompts the operator for the intended
      domain name(s) that the web server is to stand for.

   o  The ACME client presents the operator with a list of CAs from
      which it could get a certificate.  (This list will change over
      time based on the capabilities of CAs and updates to ACME
      configuration.)  The ACME client might prompt the operator for
      payment information at this point.

   o  In the background, the ACME client contacts the CA and requests
      that it issue a certificate for the intended domain name(s).

   o  The CA verifies that the client controls the requested domain
      name(s) by having the ACME client perform some action(s) that can
      only be done with control of the domain name(s).  For example, the
      CA might require a client requesting example.com to provision a
      DNS record under example.com or an HTTP resource under
      http://example.com.

   o  Once the CA is satisfied, it issues the certificate and the ACME
      client automatically downloads and installs it, potentially
      notifying the operator via email, SMS, etc.


# key
   An ACME client authenticates to the server by means of an "account
   key pair".  The client uses the private key of this key pair to sign
   all messages sent to the server.  The server uses the public key to
   verify the authenticity and integrity of messages from the client.

# ACME steps
## account creation
 The first phase of ACME is for the client to request an account with
   the ACME server.  The client generates an asymmetric key pair and
   requests a new account, optionally providing contact information,
   agreeing to terms of service (ToS), and/or associating the account
   with an existing account in another system.  The creation request is
   signed with the generated private key to prove that the client
   controls it.
   A client creates a new account with the server by sending a POST
   request to the server's newAccount URL.  The body of the request is a
   stub account object containing some subset of the following fields:

   contact (optional, array of string):  Same meaning as the
      corresponding server field defined in Section 7.1.2.

   termsOfServiceAgreed (optional, boolean):  Same meaning as the
      corresponding server field defined in Section 7.1.2.






Barnes, et al.               Standards Track                   [Page 34]

RFC 8555                          ACME                        March 2019


   onlyReturnExisting (optional, boolean):  If this field is present
      with the value "true", then the server MUST NOT create a new
      account if one does not already exist.  This allows a client to
      look up an account URL based on an account key (see
      Section 7.3.1).

   externalAccountBinding (optional, object):  Same meaning as the
      corresponding server field defined in Section 7.1.2

   POST /acme/new-account HTTP/1.1
   Host: example.com
   Content-Type: application/jose+json

   {
     "protected": base64url({
       "alg": "ES256",
       "jwk": {...},
       "nonce": "6S8IqOGY7eL2lsGoTZYifg",
       "url": "https://example.com/acme/new-account"
     }),
     "payload": base64url({
       "termsOfServiceAgreed": true,
       "contact": [
         "mailto:cert-admin@example.org",
         "mailto:admin@example.org"
       ]
     }),
     "signature": "RZPOnYoPs1PhjszF...-nh6X1qtOFPB519I"
   }

## request
  Once an account is registered, there are four major steps the client
   needs to take to get a certificate:

   1.  Submit an order for a certificate to be issued

   2.  Prove control of any identifiers requested in the certificate

   3.  Finalize the order by submitting a CSR

   4.  Await issuance and download the issued certificate

### request overview
    Client                                                   Server

         [Order]
         Signature                     ------->
                                       <-------  Required Authorizations

         [Responses]
         Signature                     ------->

                             <~~~~~~~~Validation~~~~~~~~>
                                  dns-01 or http-01

         [CSR]
         Signature                     ------->
                                       <-------          Acknowledgement

                             <~~~~~~Await issuance~~~~~~>

         [POST-as-GET request]
         Signature                     ------->
                                       <-------              Certificate

                   [] Information covered by request signatures

                           Certificate Issuance

### CSR
Once the client believes it has fulfilled the server's requirements,
   it should send a POST request to the order resource's finalize URL.
   The POST body MUST include a CSR:

   csr (required, string):  A CSR encoding the parameters for the
      certificate being requested [RFC2986].  The CSR is sent in the
      base64url-encoded version of the DER format.  (Note: Because this
      field uses base64url, and does not include headers, it is
      different from PEM.)

   POST /acme/order/TOlocE8rfgo/finalize HTTP/1.1
   Host: example.com
   Content-Type: application/jose+json

   {
     "protected": base64url({
       "alg": "ES256",
       "kid": "https://example.com/acme/acct/evOfKhNU60wg",
       "nonce": "MSF2j2nawWHPxxkE3ZJtKQ",
       "url": "https://example.com/acme/order/TOlocE8rfgo/finalize"
     }),
     "payload": base64url({
       "csr": "MIIBPTCBxAIBADBFMQ...FS6aKdZeGsysoCo4H9P",
     }),
     "signature": "uOrUfIIk5RyQ...nw62Ay1cl6AB"
   }

# revocation
         Client                                                 Server

         [Revocation request]
         Signature                    -------->

                                      <--------                 Result

                   [] Information covered by request signatures

                          Certificate Revocation

# message transport
Communications between an ACME client and an ACME server are done
over HTTPS, using JSON Web Signature (JWS) [RFC7515] to provide some
additional security properties for messages sent from the client to
the server.  HTTPS provides server authentication and
confidentiality.  With some ACME-specific extensions, JWS provides
authentication of the client's request payloads, anti-replay
protection, and integrity for the HTTPS request URL.

# challenges
The client indicates to the server that it is ready for the challenge
   validation by sending an empty JSON body ("{}") carried in a POST
   request to the challenge URL (not the authorization URL).

## HTTP challenge
   Section 8 describes a set of challenges for domain name validation.

   {
     "status": "valid",
     "expires": "2015-03-01T14:09:07.99Z",

     "identifier": {
       "type": "dns",
       "value": "www.example.org"
     },

     "challenges": [
       {
         "url": "https://example.com/acme/chall/prV_B7yEyA4",
         "type": "http-01",
         "status": "valid",
         "token": "DGyRejmCefe7v4NfDGDKfA",
         "validated": "2014-12-01T12:05:58.16Z"
       }
     ],

     "wildcard": false
   }

### challenge contents
   GET /acme/authz/1234/0 HTTP/1.1
   Host: example.com

   HTTP/1.1 200 OK
   {
     "type": "http-01",
     "url": "https://example.com/acme/authz/0",
     "status": "pending",
     "token": "LoqXcYV8q5ONbJQxbmR7SCTNo3tiAXDfowyjxAjEuX0"
   }

   A client responds to this challenge by constructing a key
   authorization from the "token" value provided in the challenge and
   the client's account key.  The client then provisions the key
   authorization as a resource on the HTTP server for the domain in
   question.

   The path at which the resource is provisioned is comprised of the
   fixed prefix ".well-known/acme-challenge/", followed by the "token"
   value in the challenge.  The value of the resource MUST be the ASCII
   representation of the key authorization.

8.1.  Key Authorizations

   Several of the challenges in this document make use of a key
   authorization string.  A key authorization is a string that expresses
   a domain holder's authorization for a specified key to satisfy a
   specified challenge, by concatenating the token for the challenge
   with a key fingerprint, separated by a "." character:

   key-authz = token || '.' || base64url(JWK_Thumbprint(accountKey))

   The "JWK_Thumbprint" step indicates the computation specified in
   [RFC7638], using the SHA-256 digest [FIPS180-4].  As noted in JWA
   [RFC7518] any prepended zero octets in the JWK object MUST be
   stripped before doing the computation.

   As specified in the individual challenges below, the token for a
   challenge is a string comprised entirely of characters in the URL-
   safe base64 alphabet.  The "||" operator indicates concatenation of

## DNS challenge

# account
 Before sending a POST request to the server, an ACME client needs to
   have a fresh anti-replay nonce to put in the "nonce" header of the
   JWS.  In most cases, the client will have gotten a nonce from a
   previous request.  However, the client might sometimes need to get a
   new nonce, e.g., on its first request to the server or if an existing
   nonce is no longer valid.